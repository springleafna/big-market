# 大营销

1. 首先将抽奖的策略初始化  
创建一个Map集合，key为抽奖生成的随机数，value为奖品Id  
每种奖品都有对应的概率（和为1？暂时为1）  
假设概率分布为：  
奖品1：0.3  
奖品2：0.2   
奖品3：0.2  
奖品4：0.1  
奖品5：0.1  
奖品6：0.05  
奖品7：0.04  
奖品8：0.0099  
奖品9：0.0001   
将概率总和除以最小的奖品概率，得到每个奖品的权重：  
1/0.0001=10000  
那么这个Map集合的大小为10000，key为0-9999，value为奖品Id  
则这10000个key中有一个位置存放的是概率为0.0001的奖品Id，有99个位置存放的是概率为0.0099的奖品Id，以此类推  
这样随机生成一个0-9999的随机数，然后根据这个随机数在Map集合中查找奖品Id，即可得到奖品  

2. rule_weight规则的策略  
根据策略Id获取到该策略实体，然后判断该策略的rule_model中是否有rule_weight规则，  
如果无则结束   
如果有，则在strategy_rule表中查找对应rule_weight规则   
比如该策略的rule_model为：4000:102,103,104,105 5000:102,103,104,105,106,107 6000:102,103,104,105,106,107,108,109
消耗4000分，必中奖范围......  
然后将这个规则转换为Map集合：Map<Integer, List<Integer>>，key为积分达标要求，value为奖品Id列表  
然后在第一步中的Map集合中去除其他没达到中奖范围的奖品Id，得到最终的奖品IdMap集合  
这样随机生成一个在该Map范围内的随机数，然后根据这个随机数在Map集合中根据key去取value即对应的奖品Id  

### 抽奖策略：

#### rule_weight规则：

rule_weight规则是指在抽奖策略中，根据用户的积分情况，给予不同的奖品权重，以达到不同奖品的概率更高的目的.  
比如：4000:102,103,104,105 5000:102,103,104,105,106,107 6000:102,103,104,105,106,107,108,109  
表示用户积分4000分以上，抽到的奖品范围为102、103、104、105   
用户积分5000分以上，奖品在102、103、104、105、106、107之中   
用户积分6000分以上，奖品在102、103、104、105、106、107、108、109之中。  

#### rule_blacklist规则：

黑名单规则，是指在抽奖策略中，将一些不合适的用户加入黑名单，从而在这些黑名单用户抽奖时返回的奖品固定为比如1积分。   

#### rule_lock规则：

积分锁规则，是指某些奖品只有达到一定的抽奖次数后才解锁。

### 抽奖规则过滤：

#### 工厂模式+策略模式+Map+自定义注解+枚举：

在抽奖时需要进行判断，该用户是否是黑名单用户，该抽奖是否有权重规则，以及抽奖后用户积分是否达标，库存是否充分等等。。。
1. 首先创建了一个ILogicFilter接口，该接口有一个方法Filter：接受一个规则物料实体对象，返回一个规则动作实体
2. 其下有三个实现类都重写了Filter方法：
 - RuleBlackListLogicFilter：黑名单过滤器，判断用户是否在黑名单中，如果在黑名单中则返回固定奖品
 - RuleWeightLogicFilter：权重过滤器，判断抽奖是否有权重规则，如果有则进行规则内的奖品抽取
 - RuleLockLogicFilter：积分过滤器，判断用户是否达标
3. 有一个自定义注解LogicStrategy，其中包含着一个枚举，表示各个过滤器的类型，该注解可以标注在所有具体的过滤器上
4. 还有一个规则工厂DefaultLogicFactory 其中的Map<String, ILogicFilter<?>> logicFilterMap用来存放所有被LogicStrategy注解的过滤器


### 抽奖基本流程：
1. 首先装配策略
2. 然后执行责任链（责任链中先判断用户是否是黑名单用户，如果是则直接返回固定奖品，如果不是则判断是否有权重规则，如果有则进行规则内的奖品抽取，如果没有则判断用户是否达标，如果达标则进行抽奖，如果不达标则返回固定奖品）

## 活动相关表：  

### 活动表：raffle_activity  
记录活动相关信息，如活动名称、活动描述、活动开始时间、活动结束时间、活动状态等。  

### 活动次数表： raffle_activity_count  
这个表的一条数据代表一个用户参与一次活动增加的抽奖次数 包含总次数，日次数，月次数等。   

### 活动sku表： raffle_activity_sku  
代表一个活动订单包含的活动信息，比如活动id，活动次数id，库存等信息。记录参与这个活动的相关活动信息以及增加的抽奖次数。    

### 活动账户表： raffle_activity_account  
代表一个用户在某个活动上的账户信息，比如用户id，活动id，以及**在该活动下的总抽奖次数以及剩余次数**等信息  

### 活动订单表： raffle_activity_order  
用户参与活动时，系统生成的订单信息，包含订单号，用户id，活动id，订单状态等信息，以及该订单**增加的抽奖次数**信息。  

基本流程：用户参与一次抽奖，首先需要**参与这个抽奖对应的活动**，活动包含了这个抽奖的抽奖策略等信息，  
也就相当于商品下单。这里的商品就是**sku表**（这个sku表记录着这个活动的Id以及活动次数Id，活动次数Id对应着用户参与活动增加的抽奖次数）  
随后系统生成一个订单，订单包含了用户id，活动id，sku表Id，订单状态等信息，以及该订单增加的抽奖次数信息。  
然后在活动账户表中将该用户在该活动下的总抽奖次数以及剩余次数进行更新。  

### 参与活动增加账户额度
用户参与一次抽奖活动：根据用户id会创建 sku 账户充值订单，给用户增加抽奖次数；  
然后根据skuId查询出对应的活动和本次sku增加的抽奖次数  
然后进行责任链的处理：  
判断活动是否有效，库存是否充足，然后对该活动库存进行扣减  
（活动库存记录在sku表中，也就是活动有参与次数的限制，每个用户参与一次，该活动的库存就扣减一次）  
如果库存不足就抛出异常，则该活动参与失败   
接着创建一个订单  
再保存该订单  
保存订单的时：  
先再订单表中插入该订单记录  
再对该订单对应的账户进行更新  
如果没有用户账户则创建  
有则直接更新  

### 领取活动扣减账户额度
用户**参与活动**是创建一个sku账户**充值订单**，对用户的账户进行抽奖次数的增加  
用户**领取活动**是**消耗抽奖次数**，生成一个用户抽奖订单，进行抽奖，扣减用户账户的抽奖次数：  
raffle_activity_account:记录某用户在某活动下的总抽奖次数，月抽奖次数，日抽奖次数以及剩余次数  
raffle_activity_day:记录某用户在某活动下的每日抽奖次数以及剩余次数   
raffle_activity_month:记录某用户在某活动下的每月抽奖次数以及剩余次数   
所有用户参与活动之后三张表的记录都会更新且是在同一个事务中进行的。    


## 策略装配
活动预热：传入活动Id
根据活动Id获取所有的sku  
将sku的剩余库存写入缓存 ：activity_sku_stock_count_key_+sku  
再将该sku的活动次数写入到缓存 ：big_market_activity_count_key_+activityCountId  
再将活动写入缓存 ：big_market_activity_key_+activityId  


策略预热：传入活动Id
根据活动Id获取对应的策略Id  
根据策略Id获取该策略下的所有奖品并写入缓存：big_market_strategy_award_list_key_+ strategyId  
再缓存所有奖品的库存：strategy_award_count_key_+ strategyId + _ + awardId  
然后不考虑权重策略配置 将所有奖品的概率范围（Map集合的长度）写入缓存：big_market_strategy_rate_range_key_+strategyId  
再将这个Map集合（key:随机数，value:奖品Id）写入缓存：big_market_strategy_rate_table_key_ + strategyId
再考虑是否存在权重策略，装配权重  
将当前策略写入缓存：big_market_strategy_key_ + strategyId   


## 执行抽奖
传入活动Id和用户Id（用户参加某个抽奖活动，该活动有对应的抽奖策略，根据策略进行抽奖） 
